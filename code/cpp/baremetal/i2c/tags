!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
I2C_ADDRESS_10B	bm_i2c.h	/^			I2C_ADDRESS_10B = 2	\/\/ 10 bits addressing mode  $/;"	e	enum:bm_i2c::__anon3
I2C_ADDRESS_7B	bm_i2c.h	/^			I2C_ADDRESS_7B	= 1,\/\/ 7  bits addressing mode  $/;"	e	enum:bm_i2c::__anon3
I2C_MODE_MASTER	bm_i2c.h	/^			I2C_MODE_MASTER			= 1,\/\/ Single Master Mode$/;"	e	enum:bm_i2c::__anon4
I2C_MODE_MULTI_MASTER	bm_i2c.h	/^			I2C_MODE_MULTI_MASTER	= 3	\/\/ Multy Master Mode$/;"	e	enum:bm_i2c::__anon4
I2C_MODE_SLAVE	bm_i2c.h	/^			I2C_MODE_SLAVE			= 2,\/\/ Slave Mode$/;"	e	enum:bm_i2c::__anon4
I2C_SPEED_FAST	bm_i2c.h	/^			I2C_SPEED_FAST			= 2,\/\/ Fm	400 kbits\/s $/;"	e	enum:bm_i2c::__anon2
I2C_SPEED_FAST_PLUS	bm_i2c.h	/^			I2C_SPEED_FAST_PLUS		= 3,\/\/ Fm+	1	Mbits\/s$/;"	e	enum:bm_i2c::__anon2
I2C_SPEED_HIGH_SPEED	bm_i2c.h	/^			I2C_SPEED_HIGH_SPEED	= 4,\/\/ Hs	3.4 Mbits\/s $/;"	e	enum:bm_i2c::__anon2
I2C_SPEED_STANDART	bm_i2c.h	/^			I2C_SPEED_STANDART		= 1,\/\/ Sm	100 kbits\/s This mode will be choosen for the constructor. $/;"	e	enum:bm_i2c::__anon2
I2C_SPEED_ULTRA_FAST	bm_i2c.h	/^			I2C_SPEED_ULTRA_FAST	= 5	\/\/ UFm	5	Mbits\/s$/;"	e	enum:bm_i2c::__anon2
I2C_STATE_ABORT	bm_i2c.h	/^			I2C_STATE_ABORT		= 7,\/\/ Aborted by user$/;"	e	enum:bm_i2c::__anon1
I2C_STATE_ERROR	bm_i2c.h	/^			I2C_STATE_ERROR		= 9	\/\/ Error happened$/;"	e	enum:bm_i2c::__anon1
I2C_STATE_LISTEN	bm_i2c.h	/^			I2C_STATE_LISTEN	= 6,\/\/ Listening$/;"	e	enum:bm_i2c::__anon1
I2C_STATE_READY	bm_i2c.h	/^			I2C_STATE_READY		= 2,\/\/ Ready$/;"	e	enum:bm_i2c::__anon1
I2C_STATE_RESET	bm_i2c.h	/^			I2C_STATE_RESET		= 1,\/\/ Not Initialized$/;"	e	enum:bm_i2c::__anon1
I2C_STATE_RX	bm_i2c.h	/^			I2C_STATE_RX		= 5,\/\/ Receiving$/;"	e	enum:bm_i2c::__anon1
I2C_STATE_TIMEOUT	bm_i2c.h	/^			I2C_STATE_TIMEOUT	= 8,\/\/ Timeout$/;"	e	enum:bm_i2c::__anon1
I2C_STATE_TX	bm_i2c.h	/^			I2C_STATE_TX		= 4,\/\/ Transmitting$/;"	e	enum:bm_i2c::__anon1
abortTransmit	bm_i2c.cpp	/^void bm_i2c::abortTransmit()$/;"	f	class:bm_i2c
arbitration	bm_i2c.cpp	/^void bm_i2c::arbitration()$/;"	f	class:bm_i2c
bm_i2c	bm_i2c.cpp	/^bm_i2c::bm_i2c(uint8_t channel, uint8_t address, bm_i2c_mode_t mode) $/;"	f	class:bm_i2c
bm_i2c	bm_i2c.h	/^class bm_i2c$/;"	c
bm_i2c_address_t	bm_i2c.h	/^		}	bm_i2c_address_t;	\/\/ Doest not require a hardware support -> device adress is sent differently$/;"	t	class:bm_i2c	typeref:enum:bm_i2c::__anon3
bm_i2c_mode_t	bm_i2c.h	/^		}	bm_i2c_mode_t;				\/\/ Only algorithm changes$/;"	t	class:bm_i2c	typeref:enum:bm_i2c::__anon4
bm_i2c_speed_t	bm_i2c.h	/^		}	bm_i2c_speed_t;				\/\/ Please note that speed modes engender a behavioural change$/;"	t	class:bm_i2c	typeref:enum:bm_i2c::__anon2
bm_i2c_state_t	bm_i2c.h	/^		}	bm_i2c_state_t;			\/\/ Typical Low Level Communication states$/;"	t	class:bm_i2c	typeref:enum:bm_i2c::__anon1
busClear	bm_i2c.cpp	/^void bm_i2c::busClear()$/;"	f	class:bm_i2c
clockStretch	bm_i2c.cpp	/^void bm_i2c::clockStretch()$/;"	f	class:bm_i2c
clockSynchronise	bm_i2c.cpp	/^void bm_i2c::clockSynchronise()$/;"	f	class:bm_i2c
freeChannel	bm_i2c.cpp	/^void bm_i2c::freeChannel()$/;"	f	class:bm_i2c
getAddress	bm_i2c.cpp	/^uint8_t bm_i2c::getAddress() const$/;"	f	class:bm_i2c
getAddressMode	bm_i2c.cpp	/^uint8_t bm_i2c::getAddressMode() const$/;"	f	class:bm_i2c
getError	bm_i2c.cpp	/^uint8_t bm_i2c::getError() const$/;"	f	class:bm_i2c
getIcIdentification	bm_i2c.cpp	/^uint8_t bm_i2c::getIcIdentification() const$/;"	f	class:bm_i2c
getIcManufacturer	bm_i2c.cpp	/^uint16_t bm_i2c::getIcManufacturer() const$/;"	f	class:bm_i2c
getIcRevision	bm_i2c.cpp	/^uint8_t bm_i2c::getIcRevision()	const$/;"	f	class:bm_i2c
getInterrupt	bm_i2c.cpp	/^uint8_t bm_i2c::getInterrupt() const$/;"	f	class:bm_i2c
getTimeout	bm_i2c.cpp	/^uint32_t bm_i2c::getTimeout() const$/;"	f	class:bm_i2c
initChannelAsMaster	bm_i2c.cpp	/^void bm_i2c::initChannelAsMaster()$/;"	f	class:bm_i2c
initChannelAsSlave	bm_i2c.cpp	/^void bm_i2c::initChannelAsSlave()$/;"	f	class:bm_i2c
m_address	bm_i2c.h	/^		uint8_t m_address;				\/\/ I2c Standrat : Address of the device to be communicated or our Slave address in Slave mode$/;"	m	class:bm_i2c
m_addressMode	bm_i2c.h	/^		bm_i2c_address_t m_addressMode;	\/\/ I2C Standart : Address type of the device to be communicated$/;"	m	class:bm_i2c
m_bufferPointer	bm_i2c.h	/^		uint8_t *m_bufferPointer;		\/\/ Buffer pointer for data to be sent & received$/;"	m	class:bm_i2c
m_channel	bm_i2c.h	/^		uint8_t m_channel;				\/\/ Hardware Specific : Selection of I2C Channel$/;"	m	class:bm_i2c
m_error	bm_i2c.h	/^		uint32_t m_error;				\/\/ The error code corresponding to that error$/;"	m	class:bm_i2c
m_fileDescriptor	bm_i2c.h	/^		uint16_t m_fileDescriptor;		\/\/ Linux : i2c file description$/;"	m	class:bm_i2c
m_fileName	bm_i2c.h	/^		char m_fileName[20];			\/\/ Linux : i2c file name$/;"	m	class:bm_i2c
m_icIdentification	bm_i2c.h	/^		uint8_t m_icIdentification;		\/\/ I2C Standart : Device information from manufacturer$/;"	m	class:bm_i2c
m_icManufacturer	bm_i2c.h	/^		uint16_t m_icManufacturer;		\/\/ I2C Standart : Device information from manufacturer $/;"	m	class:bm_i2c
m_icRevision	bm_i2c.h	/^		uint8_t m_icRevision;			\/\/ I2C Standart : Device information from manufacturer$/;"	m	class:bm_i2c
m_interruptSource	bm_i2c.h	/^		uint32_t m_interruptSource;		\/\/ Hardware Specific : Interrupt cause$/;"	m	class:bm_i2c
m_interrupttFlags	bm_i2c.h	/^		uint32_t m_interrupttFlags; 	\/\/ Hardware Specific : Interrupt flag$/;"	m	class:bm_i2c
m_mode	bm_i2c.h	/^		bm_i2c_mode_t m_mode;			\/\/ I2C Standart : Mode of our device$/;"	m	class:bm_i2c
m_regPointer	bm_i2c.h	/^		uint8_t *m_regPointer;			\/\/ Register pointer for data to be sent & received$/;"	m	class:bm_i2c
m_speed	bm_i2c.h	/^		bm_i2c_speed_t m_speed;			\/\/ I2C Standart : Trasmission speed$/;"	m	class:bm_i2c
m_state	bm_i2c.h	/^		bm_i2c_state_t m_state;			\/\/ Defined by me : Current state of this i2c Object$/;"	m	class:bm_i2c
m_timeout	bm_i2c.h	/^		uint32_t m_timeout;				\/\/ Timeout for managing communication breaks$/;"	m	class:bm_i2c
m_transferCount	bm_i2c.h	/^		uint8_t m_transferCount;		\/\/ Internal counter for the count of data Transfer$/;"	m	class:bm_i2c
m_transferSize	bm_i2c.h	/^		volatile uint8_t m_transferSize;\/\/ Size of the data to be sent or received$/;"	m	class:bm_i2c
readDeviceInfo	bm_i2c.cpp	/^void bm_i2c::readDeviceInfo()$/;"	f	class:bm_i2c
receive	bm_i2c.cpp	/^voidÂ§h bm_i2c::receive(uint8_t *Buffer, uint8_t *Reg, uint8_t *Lenght)$/;"	f	class:bm_i2c
send	bm_i2c.cpp	/^void bm_i2c::send(uint8_t *Data, uint8_t *Reg, uint8_t *Lenght)$/;"	f	class:bm_i2c
setAddress	bm_i2c.cpp	/^void bm_i2c::setAddress(uint8_t address)$/;"	f	class:bm_i2c
setAddressMode	bm_i2c.cpp	/^void bm_i2c::setAddressMode()$/;"	f	class:bm_i2c
setDma	bm_i2c.cpp	/^void bm_i2c::setDma()$/;"	f	class:bm_i2c
setInterrupt	bm_i2c.cpp	/^void bm_i2c::setInterrupt()$/;"	f	class:bm_i2c
setSpeed	bm_i2c.cpp	/^void bm_i2c::setSpeed(bm_i2c_speed_t speed)$/;"	f	class:bm_i2c
setTimeout	bm_i2c.cpp	/^void bm_i2c::setTimeout(uint8_t m_timeout)$/;"	f	class:bm_i2c
softReset	bm_i2c.cpp	/^void bm_i2c::softReset()$/;"	f	class:bm_i2c
testDeviceSpeed	bm_i2c.cpp	/^uint8_t bm_i2c::testDeviceSpeed()$/;"	f	class:bm_i2c
throwI2cError	bm_i2c.cpp	/^void bm_i2c::throwI2cError(uint16_t error)$/;"	f	class:bm_i2c
~bm_i2c	bm_i2c.cpp	/^bm_i2c::~bm_i2c()$/;"	f	class:bm_i2c
